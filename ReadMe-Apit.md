# APIT&Sybil attack

Created by: fatmo
Created time: March 25, 2023 7:02 PM
Last edited by: fatmo
Last edited time: March 25, 2023 7:43 PM

# 项目结构

```bash
ns-allinone-2.35/
│
├── ns-2.35/                    # 主文件夹
│   ├── apit/                   # apit算法文件夹
│       └── apit.h              # 算法头文件
│       └── apit.cc             # 算法实现文件
│       └── ...                 # 其他文件
│   └── sybil_drd_1.tcl         # Random网络模拟文件
│   └── sybil_drd_2.tcl         # Uniform网络模拟文件
│   └── Makefile                # 程序构筑文件
│   └── ns                      # 程序执行文件
│
├── ...                         # 其他文件夹
│
├── ReadMe-Apit                 # 项目介绍文件
```

# 使用说明

将压缩包直接解压，进入apit/ 目录，执行`make`编译源码，编译完后会在apit目录下生成ns文件

执行：

1. `ns sybil_drd_1.tcl`，仿真Random网络
2. `ns sybil_drd_2.tcl`，仿真Uniform网络

运行后会输出多个结果，取最后一次输出为最终结果:

```c
Node1: x=70.000000, y=70.000000
Node3: x=75.000000, y=65.000000
Node5: x=80.000000, y=70.000000
Node12: x=30.000000, y=60.000000
Node15: x=70.000000, y=60.000000
Node28: x=15.000000, y=15.000000
Node31: x=80.000000, y=70.000000
Node33: x=70.000000, y=70.000000
Node41: x=50.000000, y=70.000000
Node46: x=20.000000, y=10.000000
Node47: x=80.000000, y=40.000000
Node48: x=65.000000, y=35.000000
Node49: x=80.000000, y=80.000000
Node52: x=65.000000, y=52.500000
Node53: x=16.000000, y=60.000000
Node56: x=50.000000, y=70.000000
Node57: x=65.000000, y=70.000000
Node59: x=56.000000, y=56.000000
Node64: x=80.000000, y=70.000000
Node65: x=70.000000, y=70.000000
Node70: x=65.000000, y=55.000000
Node72: x=70.000000, y=60.000000
Node73: x=50.000000, y=70.000000
Node74: x=65.000000, y=70.000000
Node75: x=40.000000, y=40.000000
Node78: x=65.000000, y=70.000000
Node84: x=75.000000, y=75.000000
Node89: x=50.000000, y=80.000000
Node91: x=80.000000, y=50.000000
Node93: x=72.500000, y=50.000000
Node94: x=16.000000, y=60.000000
Node97: x=70.000000, y=30.000000
Node98: x=30.000000, y=60.000000
Node101: x=60.000000, y=73.333333
Node106: x=75.000000, y=75.000000
Node108: x=64.375000, y=43.750000
Node109: x=75.000000, y=75.000000
Node110: x=75.000000, y=60.000000
Node114: x=65.000000, y=70.000000
Node115: x=30.000000, y=60.000000
Node118: x=20.000000, y=80.000000
Node119: x=72.500000, y=50.000000
Node120: x=75.000000, y=75.000000
Node121: x=76.666667, y=80.000000
Node122: x=65.000000, y=52.500000
Node127: x=65.000000, y=35.000000
Node128: x=30.000000, y=16.666667
Node130: x=80.000000, y=70.000000
Node131: x=70.000000, y=60.000000
Node133: x=65.000000, y=35.000000
Node134: x=72.500000, y=50.000000
Node136: x=40.000000, y=40.000000
Node137: x=20.000000, y=80.000000
Node141: x=75.000000, y=35.000000
Node142: x=60.000000, y=73.333333
Node143: x=20.000000, y=10.000000
Node144: x=80.000000, y=70.000000
Node146: x=80.000000, y=70.000000
Node147: x=30.000000, y=60.000000
Node148: x=80.000000, y=50.000000
Node150: x=70.000000, y=70.000000
Node154: x=72.500000, y=50.000000
Node155: x=65.000000, y=52.500000
Node156: x=65.000000, y=52.500000
Node162: x=30.000000, y=60.000000
Node163: x=60.000000, y=23.333333
Node165: x=20.000000, y=80.000000
Node168: x=30.000000, y=60.000000
Node171: x=50.000000, y=70.000000
Node173: x=70.000000, y=70.000000
Node174: x=40.000000, y=20.000000
Node179: x=65.000000, y=70.000000
Node185: x=70.000000, y=70.000000
Node186: x=30.000000, y=60.000000
Node189: x=30.000000, y=50.000000
Node190: x=60.000000, y=60.000000
Node192: x=80.000000, y=70.000000
Node194: x=70.000000, y=70.000000
Node197: x=30.000000, y=50.000000
Node198: x=65.000000, y=70.000000
lee: 31.253350
DR: 0.22
sumF:6
FPR:0.12
```

# 关键代码说明

## **sybil_drd_1.tcl**

### **网络参数设置**

```tcl
# Generated by Topology Generator for Network Simulator (c) Elmurod Talipov
set val(chan)          Channel/WirelessChannel      ;# channel type
set val(prop)          Propagation/TwoRayGround     ;# radio-propagation model
set val(netif)         Phy/WirelessPhy/802_15_4     ;# network interface type
set val(mac)           Mac/802_15_4                 ;# MAC type
set val(ifq)           Queue/DropTail/PriQueue      ;# interface queue type
set val(ll)            LL                           ;# link layer type
set val(ant)           Antenna/OmniAntenna          ;# antenna model
set val(ifqlen)        100                  ;# max packet in ifq
set val(nn)            255              ;# number of mobilenodes
set val(anchor)        55               ;# number of anchornodes
set val(anchor_start)  200              ;# start index of anchornodes
set val(mal_start)      250
set val(mal)           5                ;# number of maliciousnodes
set val(rp)            APIT             ;# protocol tye
set val(x)             100              ;# X dimension of topography
set val(y)             80               ;# Y dimension of topography
set val(stop)          5                ;# simulation period
set val(energymodel)   EnergyModel          ;# Energy Model
set val(initialenergy) 100              ;# value
```

说明：

1. `set val(nn) 255`，定义了网络节点的总数，包括Anchor Node和Sensor Node
2. `set val(anchor) 55`，定义了Anchor Node的数量
3. `set val(anchor_start) 200`，定义了Anchor Node的起始序号（例子中，从序号200到255均为Anchor Node，序号前200为Sensor Node）
4. `set val(mal_start)	250`，Sybil Node的起始序号
5. `set val(mal) 5`，Sybil Node的数量（例子中，Sybil Node为序号250-255的Node）
6. `set val(x) 100`，网络的长度
7. `set val(y) 80`，网络的宽度

### **网络创建**

```tcl
# Position ,Color ,Label of Anchors
for {set i 0} {$i < $val(anchor_start)} { incr i } {
    $node_($i) set X_ [expr {0 + int(rand() * $val(x))}]
    $node_($i) set Y_ [expr {0 + int(rand() * $val(y))}]

}
for {set i $val(anchor_start)} {$i < $val(mal_start)} { incr i } {
    $node_($i) set X_ [expr {0 + int(rand() * $val(x))}]
    $node_($i) set Y_ [expr {0 + int(rand() * $val(y))}]
    $node_($i) label "Anchor"

}
for {set i $val(mal_start)} {$i < $val(nn)} { incr i } {
    $node_($i) set X_ [expr {0 + int(rand() * $val(x))}]
    $node_($i) set Y_ [expr {0 + int(rand() * $val(y))}]
    $node_($i) label "Malicious"
}

for {set i 0} {$i < $val(nn)} { incr i } {
        $ns initial_node_pos $node_($i) 5
        $node_($i) setPt 31.32e-3
}
```

**说明：**

1. 第一个循环定义了Sensor Node的位置，使用随机数生成器在网络范围内随机生成X和Y坐标。
2. 第二个循环定义了Anchor Node的颜色和标签，将节点的标签设置为"Anchor"。
3. 第三个循环定义了Sybil Node的颜色和标签，将节点的标签设置为"Malicious"。
4. 最后一个循环将节点放置在网络中，并使用`$ns initial_node_pos`命令设置节点的初始位置。此外，该循环还将节点的初始传输功率设置为31.32e-3。

## **sybil_drd_2.tcl**

### **网络参数设置**

```tcl
# Generated by Topology Generator for Network Simulator (c) Elmurod Talipov
set val(chan)          Channel/WirelessChannel      ;# channel type
set val(prop)          Propagation/TwoRayGround     ;# radio-propagation model
set val(netif)         Phy/WirelessPhy/802_15_4     ;# network interface type
set val(mac)           Mac/802_15_4                 ;# MAC type
set val(ifq)           Queue/DropTail/PriQueue      ;# interface queue type
set val(ll)            LL                           ;# link layer type
set val(ant)           Antenna/OmniAntenna          ;# antenna model
set val(ifqlen)        100                  ;# max packet in ifq
set val(nn)            215              ;# number of mobilenodes
set val(cols_anchor)            8        ;# 3
set val(rows_anchor)            8
set val(cols_unknown)           7
set val(rows_unknown)           8
set val(dist1)  12
set val(dist2)  6
set val(dist3)  26
set val(anchor)        10               ;# number of anchornodes
set val(anchor_start)  200              ;# start index of anchornodes
set val(mal)           5                ;# number of maliciousnodes
set val(rp)            APIT             ;# protocol tye
set val(x)             100              ;# X dimension of topography
set val(y)             80               ;# Y dimension of topography
set val(stop)          5                ;# simulation period
set val(energymodel)   EnergyModel          ;# Energy Model
set val(initialenergy) 100              ;# value
```

**说明：**

1. `set val(nn) 215`，网络中节点的总数
2. `set val(cols_anchor)	8`，Anchor Node分布的列数
3. `set val(rows_anchor)	8`，Anchor Node分布的行数
4. `set val(cols_unknown)	7`，Sensor Node分布的列数
5. `set val(rows_unknown)	8`，Sensor Node分布的行数
6. `set val(dist1)	12`，网络中每个Sensor Node的距离
7. `set val(dist2)	6`，网络中节点的偏移两
8. `set val(dist3)	26`，网络中每个Anchor Node的距离
9. `set val(anchor) 10`，Anchor Node数量
10. `set val(anchor_start) 200`，Anchor Node的起始序号
11. `set val(mal) 5`，Sybil Node的数量
12. `set val(x) 100`，网络的长度
13. `set val(y) 80`，网络的宽度

### **网络创建**

```tcl
# Position ,Color ,Label of Anchors

set k 0
for {set i 0} {$i < $val(cols_unknown) } { incr i } {
    for {set j 0} {$j < $val(rows_unknown) } { incr j } {
        if [expr {($i*$val(cols_unknown)+$j) < 50}] {
            set k [expr {($i*$val(cols_unknown)+$j)*4}]
            $node_($k) set X_ [expr {$val(dist1)/2 + $val(dist1) * $i-$val(dist2)}]
            $node_($k) set Y_ [expr {$val(dist1)/2 + $val(dist1) * $j-$val(dist2)}]
            set k [expr {($i*$val(cols_unknown)+$j)*4+1}]
            $node_($k) set X_ [expr {$val(dist1)/2 + $val(dist1) * $i+$val(dist2)}]
            $node_($k) set Y_ [expr {$val(dist1)/2 + $val(dist1) * $j-$val(dist2)}]
            set k [expr {($i*$val(cols_unknown)+$j)*4+2}]
            $node_($k) set X_ [expr {$val(dist1)/2 + $val(dist1) * $i+$val(dist2)}]
            $node_($k) set Y_ [expr {$val(dist1)/2 + $val(dist1) * $j+$val(dist2)}]
            set k [expr {($i*$val(cols_unknown)+$j)*4+3}]
            $node_($k) set X_ [expr {$val(dist1)/2 + $val(dist1) * $i-$val(dist2)}]
            $node_($k) set Y_ [expr {$val(dist1)/2 + $val(dist1) * $j+$val(dist2)}]
        }
    }
}
```

**说明：**

这段代码是用于在仿真环境中生成Sensor Node的位置信息。其中，$val(cols_unknown)$ 和 $val(rows_unknown)$ 是Sensor Node在网络的列数和行数，$val(dist1)$ 是Sensor Node的距离和 $val(dist2)$ 是偏移量，用于调整未知节点的位置。

通过一个双重循环遍历未知节点在仿真区域中的所有位置，对于每一个位置，都生成四个节点，分别代表该位置上、下、左、右四个方向上的节点。四个节点的编号依次为 $k, k+1, k+2, k+3$，其中 $k$ 是前三个循环计算出的位置的偏移量。接下来，对于每一个节点，使用以下公式计算其在仿真环境中的位置坐标：

其中，$i$ 和 $j$ 分别表示当前位置的列数和行数。通过这段代码，可以生成仿真环境中未知节点的位置信息，并存储在节点数组 $node_$ 中。

```tcl
set k 0
for {set i 0} {$i < $val(cols_anchor) } { incr i } {
    for {set j 0} {$j < $val(rows_anchor) } { incr j } {
        if [expr {($i*$val(cols_anchor)+$j) < 15}] {
            set k [expr {$i*$val(cols_anchor)+$j+$val(anchor_start)}]
            #$node_($k) set X_ [expr {0 + int(rand() * $val(x))}]
            #$node_($k) set Y_ [expr {0 + int(rand() * $val(y))}]
            $node_($k) set X_ [expr {$val(dist3)/2 + $val(dist3) * $i - $val(dist2)}]
            $node_($k) set Y_ [expr {$val(dist3)/2 + $val(dist3) * $j}]

        }
    }
}
```

**说明：**

这段代码的功能是设置Anchor Node的位置，变量 `cols_anchor` 和 `rows_anchor` 分别表示Anchor Node网格的列数和行数，`val(dist3)` 表示Anchor Node之间的距离，`val(dist2)` 表示偏移量。

首先使用两个循环嵌套来遍历Anchor Node网格中的所有位置。判断Anchor Node的序号是否小于 15，如果是，则将锚节点的位置设置为：

- X 坐标：`$val(dist3)/2 + $val(dist3) * $i - $val(dist2)`
- Y 坐标：`$val(dist3)/2 + $val(dist3) * $j`

其中，`$i` 和 `$j` 分别表示当前循环迭代到的Anchor Node网格位置的列号和行号。`$val(anchor_start)` 表示Anchor Node的起始编号，加上 `$i*$val(cols_anchor)+$j` 即可得到当前Anchor Node的编号，然后将当前Anchor Node的 X 和 Y 坐标设置为上面的公式所计算的值。

```tcl
for {set i [expr {$val(nn)-$val(mal)}]} {$i < $val(nn) } { incr i } {
    $node_($i) set X_ [expr {0 + (rand() * $val(x) * 0.75)}]
    $node_($i) set Y_ [expr {0 + (rand() * $val(y) * 0.75)}]
}
```

**说明：**

这段代码中，使用了一个for循环，循环 $val(mal) 次。在每一次循环中，对节点 $node_($i) 的位置信息进行设置，其 X 坐标设置为 0 到 $val(x) 的随机数乘以 0.75，Y 坐标同理。这里的乘以 0.75 可以理解为让节点的分布范围缩小到原先的 75%。这段代码为了在场景中随机生成Sybil Node，并设置它们的位置信息。

## **apit.h**

### **定义参数**

```c
#define DEFAULT_BEACON_INTERVAL     03 // seconds;
#define ALLOWED_MSG_LOSS                 3 // packets
#define HELLO_INTERVAL              01 // seconds;
#define Anchor_Message_Interval     0.2
#define MaxBeaconInterval               3.25
#define MinBeaconInterval               2.75
#define Detect_Interval     1.2
#define Suspect_Interval    1
#define MAX_X           100
#define MAX_Y           80
#define SYBIL_COUNT     10
```

**说明：**

只需要关注MAX_X,MAX_Y,SYBIL_COUNT三个值

MAX_X,MAX_Y分别代表网络的长、宽

**SYBIL_COUNT**表示每一个Malicious Node会随机模拟出多少个Sybil Node，如果SYBIL_COUNT = 10，则每个Malicious Node会伪造出10个坐标

## **apit.c**

### **定义参数**

```c
#define ANCHOR_START    200
#define MAL_START       250
#define ANCHOR_COUNT    50
#define MAL_COUNT       5
```

**说明：**

1. ANCHOR_START，Anchor Node的起始序号
2. MAL_START， Malicious Node的起始序号
3. ANCHOR_COUNT， Anchor Node的数量
4. MAL_COUNT， Malicious的数量

### 全局Anchor Node List

```c
// defining global anchor list 
global_anchor_listcache APIT::g_anchor_head;
void APIT::global_anchor_list_insert(ListAnchorHelloNeighborCache *item, nsaddr_t index) {
	GlobalListAnchorHelloNeighborCache	*pt = global_anchor_list_lookup(item->nb_anchor_id);
	if (!pt) {
		pt = new GlobalListAnchorHelloNeighborCache();
		pt->nb_anchor_id = item->nb_anchor_id;
		pt->posx = item->posx;
		pt->posy = item->posy;
		for (int i = 0; i < MAX_NODE_COUNT; i++)
			pt->rssi[i] = 0.0;
		if (index < MAX_NODE_COUNT)
			pt->rssi[index] = item->rssi;
		else
			printf("index overflow error ! index = %d \n", index);
		LIST_INSERT_HEAD(&g_anchor_head, pt, nb_anchorneighbor);
		ii++;
	}
	else
	{
		pt->nb_anchor_id = item->nb_anchor_id;
		pt->posx = item->posx;
		pt->posy = item->posy;
		if (index < MAX_NODE_COUNT)
			pt->rssi[index] = item->rssi;
		else
			printf("index overflow error ! index = %d \n", index);
	}
}

// Sending Hello message to all neighbors 
GlobalListAnchorHelloNeighborCache* APIT::global_anchor_list_lookup(nsaddr_t anchor_addr) {
	GlobalListAnchorHelloNeighborCache *pc = g_anchor_head.lh_first;
	int i = 0;
	for (; pc; pc = pc->nb_anchorneighbor.le_next) {
		i++;
		if (pc->nb_anchor_id == anchor_addr)
		{
			return pc;
		}
	}
	return pc;
}

void APIT::global_anchor_list_purge(void) {
	GlobalListAnchorHelloNeighborCache *pc = g_anchor_head.lh_first;
	GlobalListAnchorHelloNeighborCache *pcc;
	for (; pc; pc = pcc) {
		pcc = pc->nb_anchorneighbor.le_next;
		LIST_REMOVE(pc, nb_anchorneighbor);
		delete pc;
	}
}
```

**说明：**

定义了一个全局锚点列表：global_anchor_listcache

包含三个函数：

1. `global_anchor_list_insert()`：接受一个ListItem和一个索引作为输入。它检查列表中是否已经存在具有相同锚点ID的节点。如果不存在，则创建一个新的ListItem并将其插入到列表中。如果存在，则更新现有Item。
2. `global_anchor_list_lookup()`：接受一个锚点ID作为输入，然后在列表中查找具有相同锚点ID的节点。如果找到匹配项，则返回该节点。
3. `global_anchor_list_purge()`：从列表中删除所有节点，并释放它们的内存

```c
global_triangle_listcache APIT::g_triangle_head;
GlobalListTriangle* APIT::global_triangle_list_lookup(nsaddr_t A, nsaddr_t B, nsaddr_t C) {
	GlobalListTriangle *pc = g_triangle_head.lh_first;
	for (; pc; pc = pc->triangle.le_next) {
		if (pc->A == A && pc->B == B && pc->C == C) {
			return pc;
		}
	}
	return pc;
}

int triangle_count = 0;
bool APIT::global_triangle_list_insert(GlobalListTriangle *item) {

	GlobalListTriangle *pc = global_triangle_list_lookup(item->A, item->B, item->C);
	if (!pc) {
		LIST_INSERT_HEAD(&g_triangle_head, item, triangle);
		int value = 3;
		if (!is_contain_suspect_node(item)) {
			triangle_count++;
			if (item->suspect_coef_AB >= value) {
				global_suspect_pair_insert(item->A, item->B, item->suspect_coef_AB);
			}
			if (item->suspect_coef_BC >= value) {
				global_suspect_pair_insert(item->B, item->C, item->suspect_coef_BC);
			}
			if (item->suspect_coef_CA >= value) {
				global_suspect_pair_insert(item->C, item->A, item->suspect_coef_CA);
			}
		}
		else {
			bool is_contain_suspect_pair = false;
			if (item->suspect_coef_AB >= value) {
				global_suspect_pair_insert(item->A, item->B, item->suspect_coef_AB);
				is_contain_suspect_pair = true;
			}
			if (item->suspect_coef_BC >= value) {
				global_suspect_pair_insert(item->B, item->C, item->suspect_coef_BC);
				is_contain_suspect_pair = true;
			}
			if (item->suspect_coef_CA >= value) {
				global_suspect_pair_insert(item->C, item->A, item->suspect_coef_CA);
				is_contain_suspect_pair = true;
			}

		}
		return true;
	}
	if (item->suspect_coef_AB > pc->suspect_coef_AB)
		pc->suspect_coef_AB = item->suspect_coef_AB;
	if (item->suspect_coef_BC > pc->suspect_coef_BC)
		pc->suspect_coef_BC = item->suspect_coef_BC;
	if (item->suspect_coef_CA > pc->suspect_coef_CA)
		pc->suspect_coef_CA = item->suspect_coef_CA;
	return false;
}
```

**说明：**

用于实现APIT算法的全局三角形列表的查找和插入操作的。

定义了全局三角形列表global_triangle_listcache

1. `global_triangle_list_lookup`函数查找是否已经存在三个节点A、B和C组成的三角形，如果已经存在，则返回该三角形；
2. `global_triangle_list_insert`函数先调用`global_triangle_list_lookup`查找待插入三角形是否存在列表中，不存在则插入。将该三角形插入到全局三角形列表中同时检查该三角形是否包含可疑节点（即Sybil节点），如果不包含则对该三角形的三个边进行可疑系数的判断，并将可疑边的两个节点和相应的可疑系数插入到全局可疑节点对列表中。如果该三角形包含可疑节点，则只对包含可疑节点的边进行可疑系数的判断。如果已经存在该三角形，则将该三角形的三个边的可疑系数与新插入三角形的三个边的可疑系数进行比较，将较大的可疑系数更新到全局三角形列表中的对应边中。

### 全局可疑边列表

```c
global_suspect_pair_listcache APIT::g_suspect_pair_head;
void APIT::global_suspect_pair_insert(nsaddr_t A, nsaddr_t B, int suspect_coef) {
	Suspect_pair_listcache *pc = global_suspect_pair_lookup(A, B);
	if (!pc) {
		//printf("Find suspect pair: %d, %d\n", A, B);
		pc = new Suspect_pair_listcache;
		pc->A = A;
		pc->B = B;
		pc->suspect_coef = suspect_coef;
		LIST_INSERT_HEAD(&g_suspect_pair_head, pc, listcache);
	}
	else
	{
		if (pc->suspect_coef < suspect_coef)
			pc->suspect_coef = suspect_coef;
	}
}

Suspect_pair_listcache * APIT::global_suspect_pair_lookup(nsaddr_t A, nsaddr_t B) {
	Suspect_pair_listcache *pc = g_suspect_pair_head.lh_first;
	for (; pc; pc = pc->listcache.le_next) {
		if ((pc->A == A && pc->B == B) || (pc->A == B && pc->B == A)) {
			return pc;
		}
	}
	return pc;
}

bool APIT::is_contain_suspect_node(GlobalListTriangle* triangle) {
	Suspect_pair_listcache *pc = g_suspect_pair_head.lh_first;
	for (; pc; pc = pc->listcache.le_next) {
		if (pc->A == triangle->A || pc->A == triangle->B || pc->A == triangle->C ||
			pc->B == triangle->A || pc->B == triangle->B || pc->B == triangle->C)
			return true;
	}
	return false;
}

bool APIT::uncharted_sybil(nsaddr_t addr) {
	Suspect_pair_listcache *pc = g_suspect_pair_head.lh_first;
	for (; pc; pc = pc->listcache.le_next) {
		if (pc->A == addr || pc->B == addr)
			//printf("Hit: %d, %d, %d\n", addr, pc->A, pc->B);
			return false;
	}
	return true;
}
```

**说明：**

定义了全局可疑边列表`global_suspect_pair_listcache` 

1. `global_suspect_pair_insert` 函数将可疑对插入到这个全局列表中
2. `global_suspect_pair_lookup` 函数在这个全局列表中查找给定的可疑对
3. `is_contain_suspect_node` 函数判断给定的三角形是否包含任何一个可疑节点
4. `uncharted_sybil` 函数用于判断给定的节点是否是一个不明确的Sybil节点。

### Laplace Noise

```c
double laplaceNoisy(double sensitivety, double epsilon){
	//printf("in function\n");
	double beta = sensitivety / epsilon;
	//printf("beta: %f \n", beta);
	double u1 = rand()/(RAND_MAX+1.0);
	double u2 = rand()/(RAND_MAX+1.0);
	//printf("random: %.2f %.2f\n", u1, u2);
	double result1 = 0;
	if (u1 < 0.5) {
		result1 = -beta*log(1-u2);
	} else {
		result1 = beta*log(u2);
	}
	return result1;
}
```

**说明：**

实现Laplace Noise的函数

```c
void
APIT::SendAnchorHello()
{
	if (m_initFlag)
	{
		InitDeploymentPrint();
		m_initFlag = false;
	}
	Packet *p = Packet::alloc();
	struct hdr_cmn *ch = HDR_CMN(p);
	struct hdr_ip *ih = HDR_IP(p);
	struct hdr_anchor_hello *abcn = HDR_ANCHOR_HELLO(p);

	// Write Channel Header
	ch->ptype() = PT_APIT;
	ch->size() = IP_HDR_LEN + abcn->size();
	ch->addr_type() = NS_AF_NONE;

	// Write IP Header
	ih->saddr() = index;
	ih->daddr() = IP_BROADCAST;
	ih->ttl_ = 1;

	// Write Hello Header
	abcn->pkt_type = Anchor_Hello;
	abcn->anchor_id = index;
	iNode = (MobileNode *)(Node::get_node_by_address(index));
	abcn->posx = iNode->X() + laplaceNoisy(1, 0.6);
	abcn->posy = iNode->Y() + laplaceNoisy(1, 0.6);
	abcn->rssi = 0;
	Scheduler::instance().schedule(target_, p, 0.0);
}

/*
	Receive Anchor Hello Message
*/

void
APIT::ReceiveAnchorHello(Packet *p)
{
	struct hdr_ip *ih = HDR_IP(p);
	struct hdr_anchor_hello *anchor_hello = HDR_ANCHOR_HELLO(p);
	if (ih->saddr() == index )
	{
		Packet::free(p);
		return;
	}
	ListAnchorHelloNeighborCache *pcache = nb_anchorinfo_lookup(ih->saddr(),anchor_hello->anchor_id);
	if (pcache == 0)
	{
		double rssi = 0.0;
		rssi = p->txinfo_.RxPr;
		nb_anchorinfo_insert(ih->saddr(), anchor_hello->anchor_id, anchor_hello->posx, anchor_hello->posy, rssi);
	}
	else {
		pcache->rssi = p->txinfo_.RxPr;
		pcache->posx = anchor_hello->posx;
		pcache->posy = anchor_hello->posy;
	}
	NeighborList();
	Packet::free(p);
}
```

APIT协议中的两个函数`SendAnchorHello()`和`ReceiveAnchorHello(Packet *p)`。

1. `SendAnchorHello()`函数用于发送Anchor Hello消息，该消息包含节点的位置信息以及节点的ID。
2. `ReceiveAnchorHello(Packet *p)`函数用于接收Anchor Hello消息，将该消息缓存到邻居缓存中，并且更新邻居列表。
3. 在发送消息时，分别给X、Y坐标添加噪声

### 打印仿真情况

```c
/*
	Final state
*/

int sumS = 0;
//int sumF = 0;
void APIT::PrintFinalStat()
{
	int sumF = 0;
	double lee = 0;
	double leeSum = 0;
	int leeNum = 0;
	FILE * dumpFile;
	char dumpFileName[50] = "Table6.txt";
	dumpFile = fopen(dumpFileName, "a");
	iNode = (MobileNode *)(Node::get_node_by_address(index));
	//printf("Node%d: x=%f, y=%f\n", index, pointPositions[index][0], pointPositions[index][1]);
	if (isanchor && !m_malicious)
	{
			fprintf(dumpFile, "AnchorNode%d\n", index);
		lee = 0;
		leeNum = 0;
		leeSum = 0;

		printf("\n");
   		for(int tempI=0;tempI<ANCHOR_START;tempI++){
			lee = 0;
			MobileNode* TNode = (MobileNode *)(Node::get_node_by_address(tempI));
			if (pointPositions[tempI][0] != -1 && pointPositions[tempI][1] != -1 && pointPositions[tempI][0] <= 80 && pointPositions[tempI][1] <= 100){
				//printf("leeFirst: %f\n", lee);
				leeNum += 1;
				if (pointPositions[tempI][0] >= TNode->X()){
				    lee += (pointPositions[tempI][0] - TNode->X())*(pointPositions[tempI][0] - TNode->X());
				} else {
				    lee += (TNode->X() - pointPositions[tempI][0])*(TNode->X() - pointPositions[tempI][0]);
				}
				//printf("leeX: %f\n", lee);

				if (pointPositions[tempI][1] >= TNode->Y()){
				    lee += (pointPositions[tempI][1] - TNode->Y())*(pointPositions[tempI][1] - TNode->Y());
				} else {
				    lee += (TNode->Y() - pointPositions[tempI][1])*(TNode->Y() - pointPositions[tempI][1]);
			        }
				//printf("leeY: %f\n", lee);
				lee = sqrt(lee);
				//printf("lee: %f\n", lee);
				leeSum += lee;
				//printf("leeSum: %f\n", leeSum);
				printf("Node%d: x=%f, y=%f\n", tempI, pointPositions[tempI][0], pointPositions[tempI][1]);
				//printf("NodeResult%d: x=%f, y=%f\n", tempI, iNode->X(), iNode->Y());
			}
   		}
		leeSum = leeSum/leeNum;
   		printf("lee: %f\n", leeSum);
		//printf("lee num:%d\n", leeNum);
	}
	else if (!m_malicious)
	{
		fprintf(dumpFile, "UnknownNode%d\n", index);
	}
	else if (m_malicious)
	{
		lee = 0;
		leeNum = 0;
		leeSum = 0;

		printf("\n");
   		for(int tempI=0;tempI<ANCHOR_START;tempI++){
			lee = 0;
			MobileNode* TNode = (MobileNode *)(Node::get_node_by_address(tempI));
			if (pointPositions[tempI][0] != -1 && pointPositions[tempI][1] != -1 && pointPositions[tempI][0] <= 80 && pointPositions[tempI][1] <= 100){
				//printf("lee: %f\n", lee);
				leeNum += 1;
				if (pointPositions[tempI][0] >= TNode->X()){
				    lee += (pointPositions[tempI][0] - TNode->X())*(pointPositions[tempI][0] - TNode->X());
				} else {
				    lee += (TNode->X() - pointPositions[tempI][0])*(TNode->X() - pointPositions[tempI][0]);
				}
				//printf("lee: %f\n", lee);

				if (pointPositions[tempI][1] >= TNode->Y()){
				    lee += (pointPositions[tempI][1] - TNode->Y())*(pointPositions[tempI][1] - TNode->Y());
				} else {
				    lee += (TNode->Y() - pointPositions[tempI][1])*(TNode->Y() - pointPositions[tempI][1]);
			        }
				//printf("lee: %f\n", lee);
				lee = sqrt(lee);
				//printf("lee: %f\n", lee);
				leeSum += lee;
				//printf("leeSum: %f\n", leeSum);
				printf("Node%d: x=%f, y=%f\n", tempI, pointPositions[tempI][0], pointPositions[tempI][1]);
			}
   		}
		leeSum = leeSum/leeNum;
   		printf("lee: %f\n", leeSum);
		//printf("lee num:%d\n", leeNum);

		for (int i = 0; i < SYBIL_COUNT; i++) {
		if (uncharted_sybil(sybil_list[i])) {
			sumS += 1;
			fprintf(dumpFile, "Undetected SybilNode%d(generated by malicious node %d)\n", sybil_list[i], index);
			}
		}
	}

	float dr = (float)((SYBIL_COUNT*MAL_COUNT)-sumS)/(SYBIL_COUNT*MAL_COUNT);
	printf("DR: %.2f\n", dr);

	
	for(int iii=ANCHOR_START;iii<MAL_START;iii++){
		if (!uncharted_sybil(iii)){
			//printf("Hit: %d\n", iii);
			sumF += 1;
		}
	}
	printf("sumF:%d\n", sumF);	
	printf("FPR:%.2f\n",(float)(sumF)/(MAL_START - ANCHOR_START));
	fclose(dumpFile);
}
```

在函数中，根据节点的类型不同，执行不同的操作：

1. 如果节点是Anchor Node，函数会计算Anchor Node与其他节点之间的距离，并按照一定的规律打印Anchor Node的位置和其他节点的位置。
2. 如果节点是Unknown Node，则仅仅打印其节点编号。
3. 如果节点是Sybil Node，则首先计算其与其他节点之间的距离，然后尝试检测该Sybil Node是否被检测到。如果没有被检测到，则打印其编号。
4. 最后，函数会计算DR和FPR值。

### APIT算法

```c
// ======================================================================
//  APIT Algorithm Functions
// ======================================================================

void
APIT::apit_aggregation() {
 int result;
 PositionCache *p = pthead.lh_first;
 int nanchor = 0;
 int c=0;
     
    if (isanchor== false){
  	for( ; p; p = p->pt_position.le_next) {
	   nanchor = nanchor + 1;
        }
 
        if (nanchor >=3){
	  //printf("Node%d in apit.\n", index);
          c = fact(nanchor)/(fact(3)*fact(nanchor-3));
           inicialize_grid(); 
          inicialize_gridtemp();
          result = combination(nanchor, 3, c); 

	  GlobalListTriangle* pc = g_triangle_head.lh_first;
		  for (; pc; pc = pc->triangle.le_next) {
			  if (is_contain_suspect_node(pc)) {
				  MobileNode* ANode = (MobileNode*)(Node::get_node_by_address(pc->A));
				  MobileNode* BNode = (MobileNode*)(Node::get_node_by_address(pc->B));
				  MobileNode* CNode = (MobileNode*)(Node::get_node_by_address(pc->C));
				  grid_scan(false, ANode->X(), ANode->Y(), BNode->X(), BNode->Y(), CNode->X(), CNode->Y());
				  //printf("Delete trig:%d, %d, %d\n", pc->A, pc->B, pc->C);
			  }
		  }

          maxvalue();
          cog_algorithm();
          }
          else {
	   //printf("Node%d: nerbor anchor <= 3.\n", nanchor);
         }
    }
   
}

int
APIT::combination(int n, int k, int c) {

 int icomb[20];

      /* Setup comb for the initial combination */
	int i;
	for (i = 0; i < k; ++i)
	   icomb[i] = i;

	/* Print the first combination */
	sendComb(icomb, k, n, c);

	/* Generate and print all the other combinations */
	while (next_comb(icomb, k, n))
	    sendComb(icomb, k, n, c);
	return 0;

} 

void 
APIT::sendComb(int icomb[], int k, int n, int c) {

int i;
   inicialize_gridtemp();
   implementation(n,icomb[0], icomb[1], icomb[2], c);
   addtogrid();
   
}

int 
APIT::next_comb(int icomb[], int k, int n) {

int i = k - 1;
	++icomb[i];
	while ((i >= 0) && (icomb[i] >= n - k + 1 + i)) {
		--i;
		++icomb[i];
	}

	if (icomb[0] > n - k) /* Combination (n-k, n-k+1, ..., n) reached */
		return 0; /* No more combinations can be generated */

	/* comb now looks like (..., x, n, n, n, ..., n).
	Turn it into (..., x, x + 1, x + 2, ...) */
	for (i = i + 1; i < k; ++i)
		icomb[i] = icomb[i - 1] + 1;
	return 1;

}

int
APIT::fact(int n) {
int k;

  if (n==0)
   return 1;
  else{
    k=n*fact(n-1);
  } 
  return k;
}
```

通过找出所有可能的三角形组合来检测Sybil攻击。

`apit_aggregation()`函数，首先计算节点周围Anchor Node的数量，如果数量不小于3，则会调用`combination()`函数计算出所有可能的三角形组合。

`combination()`函数使用回溯法来生成所有的组合，并调用`sendComb()`函数处理每个组合。`sendComb()`函数将当前组合作为参数调用`implementation()`函数，该函数实现了APIT算法的核心逻辑，包括计算三角形的重心、计算三角形的面积等。

最后，`addtogrid()`函数将处理后的三角形添加到网格中。

`fact()`函数用于计算一个整数的阶乘。

### APIT算法关键函数

```c
/*
	structure implementation
*/

void 
APIT::implementation(int nanchor, int panch1, int panch2, int panch3, int c){

int neighbor=0;
int i,j,count=0;
bool add=true;

      i=0;
      PositionCache *p = pthead.lh_first;
      int anchors[nanchor];
      double anchors2[nanchor][3];
      for( ; p; p = p->pt_position.le_next) {
         anchors[i] = p->pt_anchor;
         i = i + 1;
      }
//printf("index:%d, panch1:%d, panch2:%d, panch3:%d\n", index, anchors[panch1], anchors[panch2], anchors[panch3]);

      i=0;
      p = pthead.lh_first;
      for( ; p; p = p->pt_position.le_next) {
        anchors2[i][0] = p->pt_rssi;
		anchors2[i][1] = p->pt_xpos;
        anchors2[i][2] = p->pt_ypos;
        i = i + 1;
      }
      
       ListNeighborCache *ln = lnbhead.lh_first;
       for( ; ln; ln = ln->lnb_neighbor.le_next) {
			neighbor = neighbor + 1;
       }
       int neighbors[neighbor];
       i=0;
       ln = lnbhead.lh_first;
       for( ; ln; ln = ln->lnb_neighbor.le_next) {
			neighbors[i] = ln->lnb_neighbor_id;
			i = i + 1;
       }  
        
       int neighborc=0;
       NeighborCache *nc = nbhead.lh_first;
       for( ; nc; nc = nc->nb_neighbor.le_next) {
			neighborc = neighborc + 1;
       }
       
       double neighborhood[neighborc][3];
       i=0;
       nc = nbhead.lh_first;
       for( ; nc; nc = nc->nb_neighbor.le_next) {
			neighborhood[i][0] = (double)nc->nb_neighbor_id;
			neighborhood[i][1] = (double)nc->nb_anchor_id;
			neighborhood[i][2] = nc->nb_rssi_anchor;
			i = i + 1;
       }

        double nbstate[neighbor + 2][3];
        nbstate[0][0]= (double)anchors[panch1];
        nbstate[0][1]= (double)anchors[panch2];
        nbstate[0][2]= (double)anchors[panch3];
		nbstate[1][0] = APIT::GetRSSIFromGlobalTable(index, anchors[panch1]);
		nbstate[1][1] = APIT::GetRSSIFromGlobalTable(index, anchors[panch2]);
		nbstate[1][2] = APIT::GetRSSIFromGlobalTable(index, anchors[panch3]);
              
        for(j = 2; j < neighbor+2; j++){
			nbstate[j][0] = APIT::GetRSSIFromGlobalTable(neighbors[j - 2], anchors[panch1]);
			nbstate[j][1] = APIT::GetRSSIFromGlobalTable(neighbors[j - 2], anchors[panch2]);
			nbstate[j][2] = APIT::GetRSSIFromGlobalTable(neighbors[j - 2], anchors[panch3]);
         }
         
         double myrssi1, myrssi2, myrssi3 = 0.0;
         myrssi1= nbstate[1][0];
         myrssi2= nbstate[1][1];
         myrssi3= nbstate[1][2];
	 //printf("myssi: %f %f %f\n", myrssi1, myrssi2, myrssi3);
        
         int ncount=0;
         for(i = 2; i < neighbor+2; i++){
             if ((nbstate[i][0] > 0.0)  && (nbstate[i][1] > 0.0) && (nbstate[i][2] > 0.0)) 
                ncount= ncount+1;
          }
         
         double neighborstate[ncount][3];
                 
         neighborstate[0][0] = nbstate[0][0]; 
         neighborstate[0][1] = nbstate[0][1];
         neighborstate[0][2] = nbstate[0][2];
         neighborstate[1][0] = nbstate[1][0];
         neighborstate[1][1] = nbstate[1][1];
         neighborstate[1][2] = nbstate[1][2];
 
       
         int m=2;
         for(i = 2; i <= ncount+2; i++){
           if ((nbstate[i][0] > 0.0)  && (nbstate[i][1] > 0.0) && (nbstate[i][2] > 0.0)){ 
                  neighborstate[m][0]= nbstate[i][0];
                  neighborstate[m][1]= nbstate[i][1];
                  neighborstate[m][2]= nbstate[i][2];
                  m=m+1;
            }   
          }
		 double e_ab;
		 double e_bc;
		 double e_ca;
		 int suspect_ab = 0;
		 int suspect_bc = 0;
		 int suspect_ca = 0;
		 double err =  5E-8;
		 int M_ab = 0;
		 int M_bc = 0;
		 int M_ca = 0;
		 for (i = 2; i < neighbor + 2; i++) {
			 if (nbstate[1][0] == 0.0 || nbstate[1][1] == 0) {
				 suspect_ab = 0;
			 }
			 else
			 {
				 if (nbstate[i][0] != 0 && nbstate[i][1] != 0 && M_ab < 3) {
					 M_ab++;
					 e_ab = fabs((nbstate[i][0] - nbstate[1][0]) - (nbstate[i][1] - nbstate[1][1]));
					 if (e_ab <= err)
						 suspect_ab++;

				 }
			 }
			 if (nbstate[1][1] == 0.0 || nbstate[1][2] == 0) {
				 suspect_bc = 0;
			 }
			 else
			 {
				 if (nbstate[i][1] != 0 && nbstate[i][2] != 0 && M_bc < 3) {
					 M_bc++;
					 e_bc = fabs((nbstate[i][1] - nbstate[1][1]) - (nbstate[i][2] - nbstate[1][2]));
					 if (e_bc <= err)
						 suspect_bc++;
				 }
			 }
			 if (nbstate[1][2] == 0.0 || nbstate[1][0] == 0) {
				 suspect_ca = 0;
			 }
			 else
			 {
				 if (nbstate[i][2] != 0 && nbstate[i][0] != 0 && M_ca < 3) {
					 M_ca++;
					 e_ca = fabs((nbstate[i][2] - nbstate[1][2]) - (nbstate[i][0] - nbstate[1][0]));
					 if (e_ca <= err)
						 suspect_ca++;
				 }
			 }
	 
		 }
		 GlobalListTriangle *trig = new GlobalListTriangle();
		 trig->A = anchors[panch1];
		 trig->B = anchors[panch2];
		 trig->C = anchors[panch3];
		 trig->suspect_coef_AB = suspect_ab;
		 trig->suspect_coef_BC = suspect_bc;
		 trig->suspect_coef_CA = suspect_ca;
		 
		 int tvalue = 3;
		 bool is_contain_suspect_pair = false;
		 if (trig->suspect_coef_AB >= tvalue) {
			 //printf("Find suspect pair: %d, %d\n", trig->A, trig->B);
			 is_contain_suspect_pair = true;
		 }
		 if (trig->suspect_coef_BC >= tvalue) {
			 //printf("Find suspect pair: %d, %d\n", trig->B, trig->C);
			 is_contain_suspect_pair = true;
		 }
		 if (trig->suspect_coef_CA >= tvalue) {
			 //printf("Find suspect pair: %d, %d\n", trig->C, trig->A);
			 is_contain_suspect_pair = true;
		 }

		 if (!global_triangle_list_insert(trig))
			 delete trig;
       int countfalse=0;
     
        if (ncount > 0){     
        for(j = 2; j < ncount+2; j++){
           if (((myrssi1 < neighborstate[j][0]) && (myrssi2 < neighborstate[j][1]) && (myrssi3 < neighborstate[j][2])) || 
               ((myrssi1 > neighborstate[j][0]) && (myrssi2 > neighborstate[j][1]) && (myrssi3 > neighborstate[j][2]))) {
               countfalse++;
           }
             
         } 
         if (countfalse!=0)
           add=false;
	 if (!is_contain_suspect_pair)
	//if (1)         
         	grid_scan(add, anchors2[panch1][1], anchors2[panch1][2], anchors2[panch2][1], anchors2[panch2][2],anchors2[panch3][1], anchors2[panch3][2]); 
        }   
 
}
```

**说明：**

算法通过建立三角形来检测Sybil节点。每个三角形由三个Anchor Node组成。算法通过比较锚定节点之间的RSSI值来检测Sybil节点。

函数的主要任务是实现APIT算法中的核心部分。参数nanchor表示锚定节点的数量，panch1、panch2、panch3表示三个Anchor Node的索引。该函数首先遍历pthead链表来获取Anchor Node，然后遍历lnbhead链表来获取邻居节点，最后遍历nbhead链表来获取邻居节点的邻居。在这些数据的基础上，该函数执行以下操作：

1. 创建一个包含三个锚点和它们之间的RSSI值的数组nbstate。
2. 创建一个包含所有邻居节点的RSSI值的数组neighborstate。
3. 对于三角形中的每个节点，计算它的RSSI值，并将这些值添加到数组nbstate中。
4. 检查三角形中的节点是否符合预期的RSSI值。
5. 如果不符合，将该节点标记为Sybil节点。
6. 通过`grid_scan`来定位Sybil节点的位置。

在该函数的结尾，它还检查全局三角形列表中是否包含可疑的三角形，并将这些三角形标记为Sybil节点。

```c
void
APIT::grid_scan(bool add, double x_1, double y_1, double x_2, double y_2, double x_3, double y_3) {

int i, j;
double x1,y1,x2,y2,x3,y3=0.0;
double fx, fy;
    
     x1=ceil(x_1/cellsize1)-1; x2=ceil(x_2/cellsize1)-1; x3=ceil(x_3/cellsize1)-1;
     y1=ceil(y_1/cellsize2)-1; y2=ceil(y_2/cellsize2)-1; y3=ceil(y_3/cellsize2)-1;
      
     fx = ceil((x1+x2+x3)/3.0);
     fy = ceil((y1+y2+y3)/3.0);
  
 
    Triangle((int)x1,(int)y1,(int)x2,(int)y2,(int)x3,(int)y3,add);
    Flood_fill((int)fx,(int)fy, add);
     
}
```

**说明：**

定义了一个名为grid_scan()的函数，用于将三角形网格扫描成规则的网格。该函数的参数包括一个布尔变量add，三个坐标对(x1, y1), (x2, y2), (x3, y3)，表示三角形的三个顶点坐标。函数首先将三个顶点坐标分别除以cellsize1和cellsize2，然后对结果取整，得到x1, y1, x2, y2, x3, y3六个整型变量。接下来，函数计算三个顶点的平均值，并将结果向上取整，得到fx和fy两个浮点数。最后，函数使用Triangle()函数将三角形绘制到网格上，并使用Flood_fill()函数填充网格。

```c
int diff = 0;
int diffCount = 0;
float diffFinal = 0;
void 
APIT::cog_algorithm(){

int i=0, j= 0;
double sumx=0.0, sumy= 0.0;
double cx=0.0, cy = 0.0;
double px=0.0, py = 0.0;
int nanchor=0;
//printf("Node%d in cog.\n", index);
if (isanchor != true){
//printf("Node%d in isanchor.\n", index);
//printf("Node%d maxv:%d.\n", index, maxv);
  if (maxv > 0){
   for(i = 0; i < numcell ; i++){
    for(j = 0; j < numcell; j++){
       if (grid[i][j] == maxv){
           sumx=sumx+((i+1)* cellsize1);
           sumy=sumy+((j+1)* cellsize2); 
           cx++;
           cy++;
           nanchor++;  
       }     
     }
   }
   px=sumx/cx;
   py=sumy/cy;
   maxv=0;

   pointPositions[index][0] = px;
   pointPositions[index][1] = py;

   /*printf("\n");
   for(int tempI=0;tempI<ANCHOR_START;i++){
	printf("Node%d: x=%f, y=%f\n", index, pointPositions[tempI][0], pointPositions[tempI][1]);
   }
   printf("\n");*/

   //printf("[+] Node%d: %f %f\n",index, px, py);
   //printf("[+] Node%d: %f %f\n", index, iNode->X(), iNode->Y());
   /*if (px >= iNode->X()){
      diff += px - iNode->X();
   } else {
      diff += iNode->X() - px;
   }

   if (py >= iNode->Y()){
      diff += py - iNode->Y();
   } else {
      diff += iNode->Y() - py;
   }
   diffCount += 1;*/

   //printf("Diff: %d\n", diff);
   //printf("Count: %d\n", diffCount);
   //printf("FinalDiff: %d\n", diff/diffCount);
   //printf("\n");
  }
 }

}
```

函数`cog_algorithm()` 计算出每一个Sensor Node的坐标，保存再`diffFinal`变量中